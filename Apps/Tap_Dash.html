<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tap Dash</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #e2e8f0;
            overflow: hidden;
            touch-action: manipulation; /* Prevents double-tap to zoom */
        }
        #game-container {
            width: 100%;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        canvas {
            background-color: #2d3748;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 100%;
            max-height: 100%;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none; /* Let clicks pass through to the canvas */
        }
        .ui-element {
            background-color: rgba(45, 55, 72, 0.8);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            pointer-events: all; /* Make buttons clickable */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid #4a5568;
        }
        .ui-button {
            background-color: #48bb78;
            color: #1a202c;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 1.25rem;
            transition: background-color 0.2s;
            border-bottom: 4px solid #2f855a;
        }
        .ui-button:hover, .ui-button:active {
            background-color: #38a169;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-container">
            <!-- Start Screen -->
            <div id="start-screen" class="ui-element">
                <h1 class="text-4xl mb-2">Tap Dash</h1>
                <p class="mb-6 text-gray-400">Tap to jump over obstacles!</p>
                <button id="start-button" class="ui-button">Start Game</button>
            </div>
            <!-- Game Over Screen -->
            <div id="game-over-screen" class="ui-element hidden">
                <h2 class="text-3xl mb-2">Game Over</h2>
                <p class="mb-4">Your Score: <span id="final-score">0</span></p>
                <button id="restart-button" class="ui-button">Restart</button>
            </div>
        </div>
         <!-- Score Display during gameplay -->
        <div id="score-display" class="absolute top-4 left-4 text-2xl hidden">Score: 0</div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const scoreDisplay = document.getElementById('score-display');
        const finalScoreEl = document.getElementById('final-score');

        // --- Game State ---
        let isPlaying = false;
        let animationFrameId;

        // --- Game Variables ---
        let player, gravity, obstacles, gameSpeed, score;

        // --- Game Configuration ---
        const initialGameSpeed = 2.5; // Decreased initial speed
        const gameSpeedIncrease = 0.001;
        
        // --- Player Properties ---
        const playerProps = {
            x: 50,
            y: 0, // Set dynamically
            width: 30,
            height: 30,
            color: '#63b3ed',
            jumpForce: 14, // Increased jump force
            velocityY: 0
        };

        // --- Obstacle Properties ---
        const obstacleProps = {
            width: 10,
            color: '#f56565',
            gap: 350 // Increased gap between obstacles
        };
        
        // --- Utility Functions ---
        function resizeCanvas() {
            const containerRect = gameContainer.getBoundingClientRect();
            let newWidth = containerRect.width * 0.9;
            let newHeight = containerRect.height * 0.9;
            
            // Maintain a 16:9 aspect ratio for consistency
            if (newWidth / newHeight > 16/9) {
                newWidth = newHeight * (16/9);
            } else {
                newHeight = newWidth * (9/16);
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            // Re-initialize game elements on resize if playing
            if(isPlaying) {
                // If the game was running, ending it is the simplest way
                // to avoid weird state issues on resize.
                endGame();
            } else {
                 // Draw a static frame when not playing
                 drawInitialFrame();
            }
        }

        function drawInitialFrame() {
            // Set player's initial y position based on new canvas height
            playerProps.y = canvas.height - playerProps.height - 20;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw Ground
            ctx.fillStyle = '#4a5568';
            ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
            // Draw Player
            drawPlayer({ ...playerProps });
        }


        // --- Game Logic ---
        function resetGame() {
            // Player setup
            player = {
                ...playerProps,
                y: canvas.height - playerProps.height - 20, // Start on the ground
            };
            
            // World setup
            gravity = 0.7;
            gameSpeed = initialGameSpeed;
            score = 0;
            obstacles = [];
            
            // Initial obstacle
            spawnObstacle();
            
            // Update UI
            scoreDisplay.textContent = 'Score: 0';
        }

        function spawnObstacle() {
            const minHeight = 30;
            const maxHeight = canvas.height * 0.5;
            const height = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
            
            obstacles.push({
                x: canvas.width,
                y: canvas.height - height - 20, // On the ground
                width: obstacleProps.width,
                height: height,
                passed: false
            });
        }

        function drawPlayer(p) {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.width, p.height);
        }

        function drawObstacles() {
            obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacleProps.color;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            });
        }
        
        function drawGround() {
             ctx.fillStyle = '#4a5568';
             ctx.fillRect(0, canvas.height - 20, canvas.width, 20);
        }

        function update() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- Player Physics ---
            player.velocityY += gravity;
            player.y += player.velocityY;

            // Ground collision
            const groundPosition = canvas.height - player.height - 20;
            if (player.y > groundPosition) {
                player.y = groundPosition;
                player.velocityY = 0;
            }

            // --- Obstacles ---
            // Move and remove old obstacles
            obstacles.forEach(obstacle => {
                obstacle.x -= gameSpeed;
            });
            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

            // Spawn new obstacles
            const lastObstacle = obstacles[obstacles.length - 1];
            if (canvas.width - lastObstacle.x > obstacleProps.gap) {
                spawnObstacle();
            }

            // --- Scoring ---
            obstacles.forEach(obstacle => {
                if (!obstacle.passed && player.x > obstacle.x + obstacle.width) {
                    score++;
                    obstacle.passed = true;
                    scoreDisplay.textContent = `Score: ${score}`;
                }
            });

            // --- Collision Detection ---
            if (checkCollision()) {
                endGame();
                return;
            }

            // --- Drawing ---
            drawGround();
            drawPlayer(player);
            drawObstacles();

            // Increase difficulty
            gameSpeed += gameSpeedIncrease;

            // Loop
            animationFrameId = requestAnimationFrame(update);
        }

        function checkCollision() {
            for (const obstacle of obstacles) {
                // Simple AABB collision detection
                if (
                    player.x < obstacle.x + obstacle.width &&
                    player.x + player.width > obstacle.x &&
                    player.y < obstacle.y + obstacle.height &&
                    player.y + player.height > obstacle.y
                ) {
                    return true;
                }
            }
            return false;
        }

        function playerJump() {
            // Only allow jump if player is on the ground
            const groundPosition = canvas.height - player.height - 20;
            if (isPlaying && player.y >= groundPosition - 5) { // Added a small buffer of 5px
                player.velocityY = -playerProps.jumpForce;
            }
        }

        // --- Game Flow Control ---
        function startGame() {
            isPlaying = true;
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            scoreDisplay.classList.remove('hidden');
            
            resetGame();
            update();
        }

        function endGame() {
            isPlaying = false;
            cancelAnimationFrame(animationFrameId);
            
            finalScoreEl.textContent = score;
            gameOverScreen.classList.remove('hidden');
            scoreDisplay.classList.add('hidden');
        }

        // --- Event Listeners ---
        window.addEventListener('resize', resizeCanvas);
        
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        // Handle both touch and mouse clicks for one-handed play
        document.body.addEventListener('mousedown', (e) => {
            // Prevent clicks on UI buttons from triggering a jump
            if (e.target.tagName !== 'BUTTON') {
                if (!isPlaying) {
                    startGame();
                } else {
                    playerJump();
                }
            }
        });
        document.body.addEventListener('touchstart', (e) => {
            // Prevent touches on UI buttons from triggering a jump
            if (e.target.tagName !== 'BUTTON') {
                e.preventDefault(); // Prevent mouse event from firing
                if (!isPlaying) {
                    startGame();
                } else {
                    playerJump();
                }
            }
        });

        // --- Initial Setup ---
        resizeCanvas();

    </script>
</body>
</html>

